\chapter{Технологическая часть}

\section{Выбор ЯП}

\section{Выбор языка программирования}
В данной лабораторной работе использовался язык программирования - С  \cite{Microsoft},
так как данный язык программирования предоставляет удобные библиотеки и инструменты для
работы со структурами данных и обеспечивает хорошую производительность программного продукта.
В качестве среды разработки я использовала Visual Studio Code \cite{Vs}.
Visual Studio Code подходит не только для  Windows \cite{Win},
но и для Linux \cite{Lin}, это причина,
по которой я выбрала VS code,
т.к. у меня установлена ОС Ubuntu 18.04.4 \cite{Ubuntu}.

\section{Сведения о модулях программы}

Программа состоит из следующих модулей:

\begin{itemize}
	\item main.c - главный файл программы, в котором располагается точка входа в программу;
	\item ant\_algorithm.c - реализация муравьиного алгоритма;
	\item brute\_force.c - реализация алгоритма полного перебора;
	\item matrix.c - модуль для работы с матрицей смежности;
	\item array.c - модуль для организации списка;
	\item city.c - модуль для организации списка городов;
	\item parser.c - модуль для представления результата в графическом виде.
\end{itemize}

На листингах 3.1-3.2 представлен основной код программы.

\begin{lstlisting}[label=some-code,caption=Алгоритм полного перебора]
array get_shortest_path(array cities, int matrix[LEN][LEN])
{
	array result[DEPTH_OF_RECURSION];
	array res_arr;

	int min_cost;
	int curr_cost;
	int index = 0;

	int routes_count = 0;

	del_elem(&cities, 0);
	add_elem(&res_arr, 0);
	get_routes(&cities, &res_arr, result, &routes_count);

	min_cost = get_path_cost(result[index], matrix);
	for (int i = 1; i < routes_count; i++)
	{
		curr_cost = get_path_cost(result[i], matrix);
		if (curr_cost < min_cost)
		{
			min_cost = curr_cost;
			index = i;
		}
	}

	return result[index];
}
\end{lstlisting}

\begin{lstlisting}[label=some-code,caption=Муравьиный алгоритм]
array ant_algorithm(int matrix[LEN][LEN], int count, array cities, int tmax, float p, float alpha, float beta)
{
	int Q = calculate_Q(matrix, count);

	array best_way = copy_arr(cities);
	add_elem(&best_way, get_elem(best_way, 0));

	int best_cost = get_path_cost(best_way, matrix);
	int curr_cost = 0;

	float matrix_pheromones[LEN][LEN];
	fill_matrix(matrix_pheromones, count, PHEROMONE_MIN);

	ant ants[ANTS_MAX_COUNT];

	for (int t = 0; t < tmax; t++)
	{
		generate_ants_array(ants, count);

		for (int i = 0; i < count - 1; i++)
		{
			ants_choose_way(ants, matrix_pheromones, matrix, count, alpha, beta);
		}
		for (int i = 0; i < count; i++)
			add_elem(&ants[i].way, get_elem(ants[i].way, 0));

		for (int i = 0; i < count; i++)
		{
			curr_cost = get_path_cost(ants[i].way, matrix);
			if (curr_cost < best_cost)
			{
				best_cost = curr_cost;
				best_way = copy_arr(ants[i].way);
			}
		}

		evaporation(matrix_pheromones, count, p);
		add_pheromones(matrix, matrix_pheromones, count, Q, ants);
		correct_pheromones(matrix_pheromones, count);
	}

	return best_way;
}
\end{lstlisting}


\section{Вывод}

В данном разделе были разобраны листинги рис 3.1-3.2, показывающие работу алгоритмов для решения задачи коммивояжера.